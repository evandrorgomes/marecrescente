CREATE TABLE MODRED.CATEGORIA_NOTIFICACAO (
  CANO_ID NUMBER(1) NOT NULL 
, CANO_TX_DESCRICAO VARCHAR2(100 BYTE) NOT NULL 
, CONSTRAINT PK_CANO PRIMARY KEY 
(
    CANO_ID 
  )
  USING INDEX 
  (
      CREATE UNIQUE INDEX PK_CANO ON MODRED.CATEGORIA_NOTIFICACAO  (CANO_ID ASC)
  )
  ENABLE 
);

COMMENT ON TABLE "MODRED"."CATEGORIA_NOTIFICACAO"  IS 'Tabela que armazena as categorias de notificações do sistema';   

COMMENT ON COLUMN MODRED.CATEGORIA_NOTIFICACAO.CANO_ID IS 'Chave primária para categoria de notificação';

COMMENT ON COLUMN MODRED.CATEGORIA_NOTIFICACAO.CANO_TX_DESCRICAO IS 'Descrição da categoria de notificação';



CREATE TABLE MODRED.NOTIFICACAO 
(
  NOTI_ID NUMBER NOT NULL 
, PACI_NR_RMR NUMBER NOT NULL 
, NOTI_TX_DESCRICAO VARCHAR2(255 BYTE) NOT NULL 
, CANO_ID NUMBER NOT NULL 
, NOTI_IN_NOTIFICADO NUMBER(1) DEFAULT 0 NOT NULL 
, CONSTRAINT PK_NOTI PRIMARY KEY 
  (
    NOTI_ID 
  )
  USING INDEX 
  (
      CREATE UNIQUE INDEX PK_NOTI ON NOTIFICACAO (NOTI_ID ASC)
  )
  ENABLE 
) ;

CREATE INDEX IN_FK_CANO_NOTI ON MODRED.NOTIFICACAO (CANO_ID ASC);

CREATE INDEX IN_FK_PACI_NOTI ON MODRED.NOTIFICACAO (PACI_NR_RMR ASC) ;

ALTER TABLE MODRED.NOTIFICACAO
ADD CONSTRAINT FK_NOTI_CANO FOREIGN KEY
(
  CANO_ID 
)
REFERENCES MODRED.CATEGORIA_NOTIFICACAO
(
  CANO_ID 
)
ENABLE;

ALTER TABLE MODRED.NOTIFICACAO
ADD CONSTRAINT FK_NOTI_PACI FOREIGN KEY
(
  PACI_NR_RMR 
)
REFERENCES MODRED.PACIENTE
(
  PACI_NR_RMR 
)
ENABLE;

COMMENT ON TABLE "MODRED"."NOTIFICACAO"  IS 'Tabela que armazena as notificações do sistema';   

COMMENT ON COLUMN NOTIFICACAO.NOTI_ID IS 'Chave primária de notificicação';

COMMENT ON COLUMN NOTIFICACAO.PACI_NR_RMR IS 'RMR do paciente';

COMMENT ON COLUMN NOTIFICACAO.NOTI_TX_DESCRICAO IS 'Descrição da notificação';

COMMENT ON COLUMN NOTIFICACAO.CANO_ID IS 'Referência para a tabela de categoria da notificação';

COMMENT ON COLUMN NOTIFICACAO.NOTI_IN_NOTIFICADO IS 'Indica se a notificação já foi lida (1-TRUE) ou não (0-FALSE)';

CREATE TABLE MODRED.MOTIVO_DESCARTE 
(
  MODE_ID NUMBER(1) NOT NULL 
, MODE_TX_DESCRICAO VARCHAR2(100 BYTE) NOT NULL 
, CONSTRAINT PK_MODE PRIMARY KEY 
  (
    MODE_ID 
  )
  USING INDEX 
  (
      CREATE UNIQUE INDEX PK_MODE ON MODRED.MOTIVO_DESCARTE (MODE_ID ASC)
  )
  ENABLE 
) ;

COMMENT ON TABLE "MODRED"."MOTIVO_DESCARTE"  IS 'Tabela que armazena os motivos de descarte dos exames';  

COMMENT ON COLUMN MOTIVO_DESCARTE.MODE_ID IS 'Identificação do motivo de descarte';

COMMENT ON COLUMN MOTIVO_DESCARTE.MODE_TX_DESCRICAO IS 'Descrição do motivo de descarte';


CREATE SEQUENCE MODRED.SQ_NOTI_ID INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

ALTER TABLE MODRED.EXAME 
ADD (EXAM_NR_STATUS NUMBER(1) DEFAULT 0 NOT NULL);

ALTER TABLE MODRED.EXAME 
ADD (MODE_ID NUMBER );

CREATE INDEX IN_FK_EXAM_MODE ON MODRED.EXAME (MODE_ID ASC);

COMMENT ON COLUMN EXAME.MODE_ID IS 'Referencia para motivo de descarte';

ALTER TABLE MODRED.EXAME
ADD CONSTRAINT FK_EXAM_MODE FOREIGN KEY
(
  MODE_ID 
)
REFERENCES MODRED.MOTIVO_DESCARTE
(
  MODE_ID 
)
ENABLE;


ALTER TABLE MODRED.CID_ESTAGIO_DOENCA 
ADD (CIED_NR_CURABILIDADE NUMBER );

ALTER TABLE MODRED.CID_ESTAGIO_DOENCA 
ADD (CIED_NR_Q_CONSTANTE NUMBER );

ALTER TABLE MODRED.CID_ESTAGIO_DOENCA 
ADD (CIED_NR_URGENCIA NUMBER );

COMMENT ON COLUMN CID_ESTAGIO_DOENCA.CIED_NR_CURABILIDADE IS 'Valor de curabilidade para ser usado no cálculo de score';

COMMENT ON COLUMN CID_ESTAGIO_DOENCA.CIED_NR_Q_CONSTANTE IS 'Valor q para ser usado no cálculo de score';

COMMENT ON COLUMN CID_ESTAGIO_DOENCA.CIED_NR_URGENCIA IS 'Valor de urgencia para ser usado no calculo de score';


/*Permissão de avaliador redome*/

INSERT INTO "MODRED"."PERFIL" (PERF_ID, PERF_TX_DESCRICAO) VALUES ('3', 'AVALIADOR_EXAME_HLA');
commit;


INSERT INTO "MODRED"."RECURSO" (RECU_ID, RECU_TX_SIGLA, RECU_TX_DESCRICAO) VALUES ('12', 'CONFERIR_EXAME_HLA', 'Permite conferência de exames de hla.');
INSERT INTO "MODRED"."PERMISSAO" (RECU_ID, PERF_ID, PERM_IN_COM_RESTRICAO) VALUES ('12', '3', '0');
INSERT INTO "MODRED"."USUARIO" (USUA_ID, USUA_TX_NOME, USUA_TX_USERNAME, USUA_TX_PASSWORD, USUA_IN_ATIVO) VALUES ('3', 'AVALIADOR REDOME', 'AVALIADOR_REDOME', '$2a$11$KMAfznbkZhx9mvESGy3.GewPWbSGQLVTnj5O0m7cIo5NrucDtcXT.', '1');
commit;

/*Auditoria*/

CREATE TABLE MODRED.LOCUS_EXAME_AUD 
(
  EXAM_ID NUMBER NOT NULL 
, LOCU_ID VARCHAR2(255 BYTE) NOT NULL 
, AUDI_ID NUMBER NOT NULL 
, AUDI_TX_TIPO NUMBER
, LOEX_TX_PRIMEIRO_ALELO VARCHAR2(255 BYTE) 
, LOEX_TX_SEGUNDO_ALELO VARCHAR2(255 BYTE) 
, CONSTRAINT PK_LOEA PRIMARY KEY 
  (
    EXAM_ID 
  , LOCU_ID 
  , AUDI_ID 
  )
  USING INDEX 
  (
      CREATE UNIQUE INDEX PK_LOEA ON MODRED.LOCUS_EXAME_AUD (EXAM_ID ASC, LOCU_ID ASC, AUDI_ID ASC)
  )
  ENABLE 
);

ALTER TABLE MODRED.LOCUS_EXAME_AUD
ADD CONSTRAINT FK_LOEA_AUDI FOREIGN KEY
(
  AUDI_ID 
)
REFERENCES MODRED.AUDITORIA
(
  AUDI_ID 
)
ENABLE;

CREATE INDEX "MODRED"."IN_FK_LOEA_AUDI" ON "MODRED"."LOCUS_EXAME_AUD" ("AUDI_ID");

COMMENT ON TABLE "MODRED"."LOCUS_EXAME_AUD"  IS 'Tabela de auditoria da tabela LOCUS_EXAME';  


CREATE TABLE MODRED.EXAME_AUD 
(
  EXAM_ID NUMBER NOT NULL 
, AUDI_ID NUMBER NOT NULL 
, AUDI_TX_TIPO NUMBER 
, EXAM_DT_CRIACAO TIMESTAMP 
, EXAM_DT_EXAME DATE 
, EXAM_NR_STATUS NUMBER 
, MODE_ID NUMBER 
, PACI_NR_RMR NUMBER 
, USUA_ID NUMBER 
, CONSTRAINT PK_EXAU PRIMARY KEY 
  (
    EXAM_ID 
  , AUDI_ID 
  )
  USING INDEX 
  (
      CREATE UNIQUE INDEX PK_EXAU ON MODRED.EXAME_AUD (EXAM_ID ASC, AUDI_ID ASC)
  )
  ENABLE 
);

ALTER TABLE MODRED.EXAME_AUD
ADD CONSTRAINT FK_EXAU_AUDI FOREIGN KEY
(
  AUDI_ID 
)
REFERENCES MODRED.AUDITORIA
(
  AUDI_ID 
)
ENABLE;

CREATE INDEX "MODRED"."IN_FK_EXAU_AUDI" ON "MODRED"."EXAME_AUD" ("AUDI_ID");

COMMENT ON TABLE "MODRED"."EXAME_AUD"  IS 'Tabela de auditoria da tabela EXAME';  


CREATE TABLE MODRED.METODOLOGIA_EXAME_AUD 
(
  AUDI_ID NUMBER NOT NULL 
, EXAM_ID NUMBER NOT NULL 
, METO_ID NUMBER NOT NULL 
, AUDI_TX_TIPO NUMBER
, CONSTRAINT PK_MEEA PRIMARY KEY 
  (
    AUDI_ID 
  , EXAM_ID 
  , METO_ID 
  )
  USING INDEX 
  (
      CREATE UNIQUE INDEX PK_MEEA ON MODRED.METODOLOGIA_EXAME_AUD (AUDI_ID ASC, EXAM_ID ASC, METO_ID ASC)
  )
  ENABLE 
) ;

ALTER TABLE METODOLOGIA_EXAME_AUD
ADD CONSTRAINT FK_MEEA_AUDI FOREIGN KEY
(
  AUDI_ID 
)
REFERENCES MODRED.AUDITORIA
(
  AUDI_ID 
)
ENABLE;

CREATE INDEX "MODRED"."IN_FK_MEEA_AUDI" ON "MODRED"."METODOLOGIA_EXAME_AUD" ("AUDI_ID");

COMMENT ON TABLE "MODRED"."METODOLOGIA_EXAME_AUD"  IS 'Tabela de auditoria da tabela METODOLOGIA_EXAME';  

/*script para popular exame*/

INSERT INTO  MODRED.AUDITORIA
 SELECT MODRED.SQ_AUDI_ID.NEXTVAL , TO_TIMESTAMP('2017-09-28 13:26:28.453000000', 'YYYY-MM-DD HH24:MI:SS.FF'), 'MEDICO'
    FROM EXAME;
COMMIT;
INSERT INTO "MODRED"."EXAME_AUD" 
   (EXAM_ID, 
	AUDI_ID,
	AUDI_TX_TIPO, 
	EXAM_DT_CRIACAO, 
	EXAM_DT_EXAME, 
	EXAM_NR_STATUS, 
	MODE_ID, 
	PACI_NR_RMR, 
	USUA_ID
	)
    SELECT EXAM_ID
    ,  MODRED.SQ_AUDI_ID.CURRVAL - (SELECT COUNT(*) FROM "MODRED"."EXAME_AUD")
    , 0
    , EXAM_DT_CRIACAO
    , EXAM_DT_EXAME
    , EXAM_NR_STATUS
    , MODE_ID
    , PACI_NR_RMR
    , USUA_ID
    FROM EXAME;
COMMIT;

INSERT INTO  MODRED.AUDITORIA
 SELECT MODRED.SQ_AUDI_ID.NEXTVAL , TO_TIMESTAMP('2017-09-28 13:26:28.453000000', 'YYYY-MM-DD HH24:MI:SS.FF'), 'MEDICO'
    FROM LOCUS_EXAME;
COMMIT;
INSERT INTO "MODRED"."LOCUS_EXAME_AUD" 
   (
    EXAM_ID, 
	LOCU_ID, 
	AUDI_ID, 
	AUDI_TX_TIPO, 
	LOEX_TX_PRIMEIRO_ALELO, 
	LOEX_TX_SEGUNDO_ALELO
	)
    SELECT EXAM_ID
    ,LOCU_ID
    , MODRED.SQ_AUDI_ID.CURRVAL - (SELECT COUNT(*) FROM "MODRED"."LOCUS_EXAME_AUD")
    , 0
    ,LOEX_TX_PRIMEIRO_ALELO
	,LOEX_TX_SEGUNDO_ALELO
    FROM LOCUS_EXAME;
COMMIT;
INSERT INTO  MODRED.AUDITORIA
 SELECT MODRED.SQ_AUDI_ID.NEXTVAL , TO_TIMESTAMP('2017-09-28 13:26:28.453000000', 'YYYY-MM-DD HH24:MI:SS.FF'), 'MEDICO'
    FROM METODOLOGIA_EXAME;
COMMIT;
INSERT INTO "MODRED"."METODOLOGIA_EXAME_AUD" 
   (
    AUDI_ID
    , EXAM_ID
	, METO_ID
	, AUDI_TX_TIPO
	)
    SELECT 
    MODRED.SQ_AUDI_ID.CURRVAL - (SELECT COUNT(*) FROM "MODRED"."LOCUS_EXAME_AUD")
	,EXAM_ID 
	,METO_ID 
	,0
    FROM METODOLOGIA_EXAME;
COMMIT;


/*Atualização dos dados de CID para testes de cálculo com score*/

UPDATE MODRED.CID_ESTAGIO_DOENCA SET CIED_NR_CURABILIDADE =  round(dbms_random.value(1,100))
, CIED_NR_Q_CONSTANTE =  round(dbms_random.value(1,100))
, CIED_NR_URGENCIA =   round(dbms_random.value(1,100));
commit;

/* Atualizando cid para setar os valores para calculo com score quando não houver estagio*/
ALTER TABLE CID 
ADD (CID_NR_CURABILIDADE NUMBER );

ALTER TABLE CID 
ADD (CID_NR_Q_CONSTANTE NUMBER );

ALTER TABLE CID 
ADD (CID_NR_URGENCIA NUMBER );

COMMENT ON COLUMN CID.CID_NR_CURABILIDADE IS 'Valor de curabilidade para ser usado no cálculo de score';

COMMENT ON COLUMN CID.CID_NR_Q_CONSTANTE IS 'Valor q para ser usado no cálculo de score';

COMMENT ON COLUMN CID.CID_NR_URGENCIA IS 'Valor de urgencia para ser usado no calculo de score';


UPDATE MODRED.CID SET CID_NR_CURABILIDADE =  round(dbms_random.value(1,100))
, CID_NR_Q_CONSTANTE =  round(dbms_random.value(1,100))
, CID_NR_URGENCIA =   round(dbms_random.value(1,100))
where cid_id not in (select cid_id from cid_estagio_doenca);


-- INSERINDO CATEGORIAS PARA NOTIFICAÇÃO
INSERT INTO MODRED.CATEGORIA_NOTIFICACAO (CANO_ID, CANO_TX_DESCRICAO) VALUES (1, 'Exame');
COMMIT;

DROP INDEX IN_FK_CANO_NOTI;

DROP INDEX IN_FK_PACI_NOTI;

CREATE INDEX IN_FK_NOTI_CANO ON MODRED.NOTIFICACAO (CANO_ID ASC);

CREATE INDEX IN_FK_NOTI_PACI ON MODRED.NOTIFICACAO (PACI_NR_RMR ASC) ;
COMMIT;

-- Ajustes nos scripts
INSERT INTO MODRED.USUARIO_PERFIL SELECT U.USUA_ID, 3 FROM MODRED.USUARIO U WHERE U.USUA_TX_USERNAME='AVALIADOR_REDOME';
COMMIT;


--Dando permissão de leitura do cabeçalho de identificação do paciente ao avaliador do redome
INSERT INTO "MODRED"."PERMISSAO" (RECU_ID, PERF_ID, PERM_IN_COM_RESTRICAO) VALUES ('8', '3', '0');
COMMIT;


--05/10/2017 (Queiroz)
/* Function que irá buscar o score a partir de um rmr */
create or replace FUNCTION get_score( paciente_id IN NUMBER )
  RETURN NUMBER
IS
  estagio_doenca_id NUMBER; 
  pontos_paciente_q_const NUMBER;
  dt_nascimento DATE;
  dt_cadastro DATE;
  idade NUMBER;
  diff_dias_cadastro NUMBER;
  cid_id_paci NUMBER;
  curabilidade NUMBER;
  q_constante NUMBER;
  urgencia NUMBER;
      
BEGIN
      
    select esdo_id into estagio_doenca_id from (select esdo_id  from evolucao where paci_nr_rmr = paciente_id order by evol_dt_criacao desc) where ROWNUM = 1  ;
    select cid_id into cid_id_paci from (select cid_id from diagnostico where paci_nr_rmr = paciente_id) where rownum = 1;
    -- quando estagio id for nula, devo buscar os parametros na propria cid
    IF estagio_doenca_id is null THEN                
        select CID_NR_CURABILIDADE,CID_NR_Q_CONSTANTE,CID_NR_URGENCIA INTO curabilidade,q_constante,urgencia from cid WHERE CID_ID = cid_id_paci;       
    ELSE        
        select CIED_NR_CURABILIDADE,CIED_NR_Q_CONSTANTE,CIED_NR_URGENCIA INTO curabilidade,q_constante,urgencia from cid_estagio_doenca WHERE ESDO_ID = estagio_doenca_id AND CID_ID = cid_id_paci;               
    END IF;
    
    select paci_dt_nascimento, paci_dt_cadastro into dt_nascimento ,dt_cadastro from paciente where paci_nr_rmr = paciente_id;
    
    --Recupera a idade do paciente
    SELECT trunc((months_between(sysdate, dt_nascimento))/12) AS idade into idade FROM DUAL;
    
    pontos_paciente_q_const:=0;  
    --Calcula pontos do paciente se for menor de 13 anos
    IF idade < 13 THEN
        pontos_paciente_q_const := 20;
        
    END IF;
    
    -- Calcula pontos do paciente com a seguinte regra:
    -- Adiciona 0.33 pontos a cada dia após o cadastro do paciente
    SELECT (TRUNC (TO_DATE(SYSDATE,'dd/mm/yyyy')) - TO_DATE (dt_cadastro, 'dd/mm/yyyy')) INTO diff_dias_cadastro FROM DUAL;
    pontos_paciente_q_const := pontos_paciente_q_const + diff_dias_cadastro*0.33;
    DBMS_OUTPUT.PUT_LINE (pontos_paciente_q_const + curabilidade + q_constante + urgencia);
    return pontos_paciente_q_const + curabilidade + q_constante + urgencia;
  
END;
COMMIT;

-- VALORES PARA MOTIVO DE DESCARTE
INSERT INTO MODRED.MOTIVO_DESCARTE (MODE_ID, MODE_TX_DESCRICAO) VALUES (1, 'Arquivo corrompido');
INSERT INTO MODRED.MOTIVO_DESCARTE (MODE_ID, MODE_TX_DESCRICAO) VALUES (2, 'Arquivo não corresponde a um exame do paciente');
COMMIT;

---JOB---
ALTER TABLE MODRED.VALOR_NMDP 
ADD (AUX CLOB );

UPDATE MODRED.VALOR_NMDP SET AUX = VANM_TX_SUBTIPO;

ALTER TABLE MODRED.VALOR_NMDP 
DROP COLUMN VANM_TX_SUBTIPO;

ALTER TABLE MODRED.VALOR_NMDP 
ADD (VANM_TX_SUBTIPO CLOB );

UPDATE MODRED.VALOR_NMDP SET VANM_TX_SUBTIPO = AUX;

ALTER TABLE MODRED.VALOR_NMDP 
DROP COLUMN AUX;

ALTER TABLE MODRED.VALOR_NMDP  
MODIFY (VANM_TX_SUBTIPO NOT NULL);

ALTER TABLE MODRED.VALOR_NMDP RENAME COLUMN VAMN_IN_AGRUPADO TO VANM_IN_AGRUPADO;

ALTER TABLE MODRED.VALOR_NMDP 
ADD (VANM_DT_ULTIMA_ATUALIZACAO_ARQ DATE );

ALTER TABLE MODRED.VALOR_NMDP 
ADD (VANM_NR_QUANTIDADE NUMBER DEFAULT 0 );

COMMENT ON COLUMN MODRED.VALOR_NMDP.VANM_TX_SUBTIPO IS 'VALORES ALELICOS';
COMMENT ON COLUMN MODRED.VALOR_NMDP.VANM_DT_ULTIMA_ATUALIZACAO_ARQ IS 'Ultima data de atualização do arquivo';
COMMENT ON COLUMN MODRED.VALOR_NMDP.VANM_NR_QUANTIDADE IS 'Quantidade de subtipos';

update MODRED.valor_nmdp set VANM_NR_QUANTIDADE = REGEXP_COUNT(VANM_TX_SUBTIPO, '/') + 1;
commit;

create global temporary table MODRED.TEMP_VALOR_NMDP
(
  TEVN_ID_CODIGO VARCHAR2(10 BYTE) NOT NULL 
, TEVN_TX_SUBTIPO CLOB NOT NULL 
, TEVN_IN_AGRUPADO NUMBER(1, 0) DEFAULT 0 NOT NULL 
, TEVN_DT_ULTIMA_ATUALIZACAO_ARQ DATE 
, TEVN_NR_QUANTIDADE NUMBER DEFAULT 0 
, CONSTRAINT PK_TEVN PRIMARY KEY 
  (
    TEVN_ID_CODIGO 
  )
  ENABLE 
) on commit preserve rows;

COMMENT ON TABLE MODRED.TEMP_VALOR_NMDP IS 'TABELA TEMPORÁRIA DE VALORES NMDP PARA ATUALIZAÇÃO';
COMMENT ON COLUMN MODRED.TEMP_VALOR_NMDP.TEVN_ID_CODIGO IS 'CÓDIGO NMDP';
COMMENT ON COLUMN MODRED.TEMP_VALOR_NMDP.TEVN_TX_SUBTIPO IS 'VALORES ALELICOS';
COMMENT ON COLUMN MODRED.TEMP_VALOR_NMDP.TEVN_IN_AGRUPADO IS 'DEFINE SE O VALOR ALELIXO ESTA AGRUPADO EX: 13:05/13:06';
COMMENT ON COLUMN MODRED.TEMP_VALOR_NMDP.TEVN_DT_ULTIMA_ATUALIZACAO_ARQ IS 'Ultima data de atualização do arquivo';
COMMENT ON COLUMN MODRED.TEMP_VALOR_NMDP.TEVN_NR_QUANTIDADE IS 'Quantidade de subtipos';

CREATE TABLE MODRED.SPLIT_VALOR_DNA
(	LOCU_ID VARCHAR2(4 BYTE) NOT NULL, 
	SPVD_TX_GRUPO_ALELICO VARCHAR2(3 BYTE) NOT NULL, 
	SPVD_TX_VALOR_ALELICO VARCHAR2(20 BYTE) NOT NULL,
	SPVD_IN_COMPARA_NMDP NUMBER DEFAULT 0, 
	SPVD_TX_VERSAO VARCHAR2(6 BYTE),
	SPVD_IN_ATIVO NUMBER  DEFAULT 1,
    CONSTRAINT PK_SPVD PRIMARY KEY 
    (
        LOCU_ID,
        SPVD_TX_GRUPO_ALELICO, 
        SPVD_TX_VALOR_ALELICO 
    ) ENABLE
); 

COMMENT ON TABLE MODRED.SPLIT_VALOR_DNA IS 'TABELA DE VALORES DNA SEPARADOS POR GRUPO E PRIMEIRO ALELO';
COMMENT ON COLUMN MODRED.SPLIT_VALOR_DNA.LOCU_ID IS 'Chave estrangeira para locus';
COMMENT ON COLUMN MODRED.SPLIT_VALOR_DNA.SPVD_TX_GRUPO_ALELICO IS 'Valor do grupo alelico';
COMMENT ON COLUMN MODRED.SPLIT_VALOR_DNA.SPVD_TX_VALOR_ALELICO IS 'Valor alelico';
COMMENT ON COLUMN MODRED.SPLIT_VALOR_DNA.SPVD_IN_COMPARA_NMDP IS 'Flag que identifica se o valor será usuado para comparação com nmdp';
COMMENT ON COLUMN MODRED.SPLIT_VALOR_DNA.SPVD_TX_VERSAO IS 'Versão do arquivo em que foi gerado o split';
COMMENT ON COLUMN MODRED.SPLIT_VALOR_DNA.SPVD_IN_ATIVO IS 'Status do valor';

create table MODRED.SPLIT_NMDP
(
  TEVN_ID_CODIGO VARCHAR2(10 BYTE) NOT NULL 
, SPNM_TX_GRUPO_ALELICO VARCHAR2(3 BYTE) not null 
, SPNM_TX_VALOR_ALELICO VARCHAR2(4 BYTE) NOT NULL
, SPNM_DT_VERSAO DATE
, CONSTRAINT PK_SPNM PRIMARY KEY 
    (
        TEVN_ID_CODIGO,
        SPNM_TX_GRUPO_ALELICO, 
        SPNM_TX_VALOR_ALELICO 
    ) ENABLE
);

CREATE INDEX MODRED.IN_GRU_ALELICO_VALOR_ALELICO ON MODRED.SPLIT_NMDP ('SPNM_TX_GRUPO_ALELICO', 'SPNM_TX_VALOR_ALELICO');

COMMENT ON TABLE MODRED.SPLIT_NMDP IS 'TABELA TEMPORÁRIA DE VALORES NMDP SEPARADOS POR GRUPO E VALOR ALELO';
COMMENT ON COLUMN MODRED.SPLIT_NMDP.TEVN_ID_CODIGO IS 'CÓDIGO NMDP';
COMMENT ON COLUMN MODRED.SPLIT_NMDP.SPNM_TX_GRUPO_ALELICO IS 'Valor do grupo alelico';
COMMENT ON COLUMN MODRED.SPLIT_NMDP.SPNM_TX_VALOR_ALELICO IS 'Valor alelico';
COMMENT ON COLUMN MODRED.SPLIT_NMDP.SPNM_DT_VERSAO IS 'Data do arquivo';
